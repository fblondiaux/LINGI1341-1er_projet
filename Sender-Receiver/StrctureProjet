%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                 Sender
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sender avec au moins 2 arguments : hostname et port.
hostname = adresse IPV6 du receibver, port numéro sur lequel receiver a été lancé.

0. Importer les fichers communs de FormatSegments et de EnvoyerRecevoir.
1. Récuperer les arguments
2. Getopt pour voir si -f est présent. Si oui : il faut utiliser le ficher pour
    aller chercher les données à envoyer.
  Q: SI le fichier est plus grand que ce que l'on peux envoyer on envoie le max
  à chaque fois jusqu'à ce qu'on ait fini le fichier ?
3. Si -f pas présent -> sender envoie ce qu'il lit sur l'entrée standard.
4. Transformer l'adresse donéée avec real_address
5. create_socket
7.read_write_loop
8. Close

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                 Reciever
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Reciever avec au moins 2 arguments : hostname et port.
hostname = adresse IPV6 avec laquelle il doit accepter une connection ( ::  =
accepter toutes les interfaces , port numéro sur lequel receiver écoute.

0. Importer les fichers communs de FormatSegments et de EnvoyerRecevoir.
1. Récuperer les arguments
2. Getopt pour voir si -f est présent. Si oui : il faut utiliser le ficher pour
    écrire les données reçues.
3. Si -f pas présent -> sender écrit sur la sortie standard.
4. Transformer l'adresse donéée avec real_address.
5. create_socket
6. wait_for_client
6.read_write_loop
7. Close

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                read_write_loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

1. initialiser la read_write_loop avec soit l'entrée standard soit le fichier.

Actualiser les windows, vérifier le type, renvoyer des Nack.
